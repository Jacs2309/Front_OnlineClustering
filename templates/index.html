<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Clustering Online Multimodal</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background: #f4f4f4; }
        .controls { background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        #output { 
            background: #222; color: rgb(255, 255, 255); padding: 15px; 
            height: 300px; overflow-y: scroll; font-family: monospace;
            margin-top: 20px; border-radius: 5px;
        }
        .stats { display: flex; gap: 20px; margin-top: 10px; }
        .stat-card { background: #fff; padding: 10px; border-radius: 5px; flex: 1; border: 1px solid #ddd; }
    </style>
</head>
<body>
    <div class="controls">
        <h1>Clustering de Imágenes Online</h1>
        <div style="display: flex; gap: 15px; align-items: flex-end; flex-wrap: wrap;">
            <div>
                <label>Carpeta:</label><br>
                <input type="file" id="folderInput" webkitdirectory directory multiple>
            </div>
            <div>
                <label>Semilla:</label><br>
                <input type="number" id="seedInput" value="42" style="width: 50px;">
            </div>
            <div>
                <label>N° Clusters (K):</label><br>
                <input type="number" id="kInput" value="4" style="width: 50px;">
            </div>
            <div>
                <label>Tamaños Máx (lista):</label><br>
                <input type="text" id="maxSizesInput" value="330, 330, 330, 330" style="width: 120px;" title="Ejemplo: 50, 100, 30, 20">
            </div>
            <button onclick="startProcess()" id="btnRun" style="background: #1ca01c; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">Iniciar</button>
            <button onclick="resetAll()" id="btnReset" style="background: #ff4444; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">Reiniciar</button>
        </div>
    </div>

    <div id="output">Esperando selección de carpeta...</div>

    <div class="controls" style="margin-top: 20px;">
        <h2>Resultados de Evaluación</h2>
        <div id="trueLabels" style="margin-bottom: 10px; font-style: italic;">Clases detectadas: —</div>
        <button onclick="fetchMetrics()" id="btnMetrics" style="background: #4479ff; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer;">Calcular Métricas</button>
        
        <div style="display: flex; gap: 20px; margin-top: 15px;">
            <div style="flex: 1;">
                <h3 style="font-size: 14px; color: #666;">Métricas Externas (Ground Truth)</h3>
                <table id="externalTable" style="width: 100%; border-collapse: collapse; display: none;">
                    <thead>
                        <tr style="background: #eee;">
                            <th style="border: 1px solid #ccc; padding: 5px;">Método</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">ARI</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">NMI</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">AMI</th>
                        </tr>
                    </thead>
                    <tbody id="externalBody"></tbody>
                </table>
            </div>
            <div style="flex: 1;">
                <h3 style="font-size: 14px; color: #666;">Métricas Internas (Estructura)</h3>
                <table id="internalTable" style="width: 100%; border-collapse: collapse; display: none;">
                    <thead>
                        <tr style="background: #eee;">
                            <th style="border: 1px solid #ccc; padding: 5px;">Método</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">Silueta</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">Dunn</th>
                            <th style="border: 1px solid #ccc; padding: 5px;">Instancias por Cluster</th>
                        </tr>
                    </thead>
                    <tbody id="internalBody"></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        let stopProcess = false;
        let estaProcesando = false;
        let procesoCompletado = false;
        let detectedLabels = new Set();

        function shuffleWithSeed(array, seed) {
            let m = array.length;
            let t, i;
            let currentSeed = seed;

            // Función auxiliar interna para generar pseudo-aleatorios consistentes
            function getNextRandom() {
                const x = Math.sin(currentSeed++) * 10000;
                return x - Math.floor(x);
            }

            while (m > 0) {
                // Elegir un elemento restante
                i = Math.floor(getNextRandom() * m--);

                // Intercambiarlo con el elemento actual
                t = array[m];
                array[m] = array[i];
                array[i] = t;
            }
            return array;
        }

        async function startProcess() {
            const input = document.getElementById('folderInput');
            const btnRun = document.getElementById('btnRun');
            const output = document.getElementById('output');
            const kValue = parseInt(document.getElementById('kInput').value);
            const maxSizesStr = document.getElementById('maxSizesInput').value;
           const maxSizesArray = maxSizesStr.split(',')
                                     .map(s => s.trim())
                                     .filter(s => s !== "")
                                     .map(s => parseInt(s));
            const seedValue = parseInt(document.getElementById('seedInput').value);
            
            if (input.files.length === 0) {
                alert("Por favor, selecciona una carpeta primero.");
                return;
            }

            if (maxSizesArray.length !== kValue) {
                alert(`La lista de tamaños (${maxSizesArray.length}) debe coincidir con K (${kValue})`);
                return;
            }

            try {
                await fetch('http://localhost:5001/reset', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ k: parseInt(kValue), max_size: maxSizesArray, seed: parseInt(seedValue) })
                });
                console.log("Backend sincronizado con K=" + kValue);
                console.log("Backend sincronizado con tamaños=" + maxSizesArray);
            } catch (e) {
                alert("No se pudo conectar con el servidor.");
                return;
            }

            // Resetear flag y deshabilitar botones al iniciar
            procesoCompletado = false;
            btnRun.disabled = true;
            detectedLabels.clear();
            
            // 1. Obtener TODOS los archivos de todas las subcarpetas seleccionadas
            let allFiles = Array.from(input.files).filter(f => 
                f.name.match(/\.(jpg|jpeg|png)$/i)
            );

            // 2. SHUFFLE CRÍTICO: Mezclamos todo el mazo de cartas (imágenes de todas las carpetas)
            // Esto garantiza que el buffer de inicialización reciba muestras de varias clases
            output.textContent = `Barajando ${allFiles.length} archivos con semilla: ${seedValue}...\n`;
            allFiles = shuffleWithSeed(allFiles, seedValue);
            
            const BATCH_SIZE = 32;

            for (let i = 0; i < allFiles.length; i += BATCH_SIZE) {
                if (stopProcess) {
                    stopProcess = false;
                    break;
                }

                const batch = allFiles.slice(i, i + BATCH_SIZE);
                const formData = new FormData();

                batch.forEach(file => {
                    // Extraer etiqueta
                    const pathParts = file.webkitRelativePath.split('/');
                    const label = pathParts.length > 1 ? pathParts[pathParts.length - 2] : "raiz";
                    
                    detectedLabels.add(label);
                    formData.append("images", file); // Misma llave para múltiples archivos
                    formData.append("labels", label);
                });

                try {
                    const res = await fetch('http://localhost:5001/process', {
                        method: 'POST',
                        body: formData
                    });
                    const data = await res.json();
                    
                    // El backend ahora devuelve una lista en data.results
                    data.results.forEach(resImg => {
                        updateUI(resImg.filename, resImg);
                    });
                    
                } catch (e) {
                    console.error("Error en el batch:", e);
                }
            }

            procesoCompletado = true; // Activamos el flag
            btnRun.disabled = false;
            output.textContent += "\nProceso finalizado. Ya puede calcular las métricas.\n";
            const labelsDiv = document.getElementById('trueLabels');
            labelsDiv.innerHTML =
                "<strong>Clases detectadas:</strong> " +
                Array.from(detectedLabels).sort().join(", ");
            if(!stopProcess){
                alert("Proceso completo. Métricas disponibles.");
            }

        }
        async function fetchMetrics() {
            if (!procesoCompletado) {
                alert("El proceso no ha finalizado."); return;
            }

            try {
                const res = await fetch('http://localhost:5001/metrics');
                const data = await res.json();
                
                const extBody = document.getElementById('externalBody');
                const intBody = document.getElementById('internalBody');
                extBody.innerHTML = ""; intBody.innerHTML = "";
                
                for (let mode in data) {
                    const m = data[mode];
                    if (m.error) continue;

                    // Fila Externa
                    extBody.innerHTML += `<tr>
                        <td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">${mode.toUpperCase()}</td>
                        <td style="border: 1px solid #ccc; padding: 8px;">${m.ari}</td>
                        <td style="border: 1px solid #ccc; padding: 8px;">${m.nmi}</td>
                        <td style="border: 1px solid #ccc; padding: 8px;">${m.ami}</td>
                    </tr>`;

                    // Fila Interna
                    const distText = m.distribution.join(" | ");
                    intBody.innerHTML += `<tr>
                        <td style="border: 1px solid #ccc; padding: 8px; font-weight: bold;">${mode.toUpperCase()}</td>
                        <td style="border: 1px solid #ccc; padding: 8px; background: #f0f7ff;">${m.silhouette}</td>
                        <td style="border: 1px solid #ccc; padding: 8px; background: #f0f7ff;">${m.dunn}</td>
                        <td style="border: 1px solid #ccc; padding: 8px; font-family: monospace; font-size: 12px; background: #f9f9f9;">
                            ${distText}
                        </td>
                        <td style="border: 1px solid #ccc; padding: 8px;">${m.samples}</td>
                    </tr>`;
                }
                
                document.getElementById('externalTable').style.display = "table";
                document.getElementById('internalTable').style.display = "table";
            } catch (err) {
                alert("Error al obtener métricas: " + err.message);
            }
        }

        async function resetAll() {
            stopProcess=true;
            const k = parseInt(document.getElementById('kInput').value);
            const maxSizesStr = document.getElementById('maxSizesInput').value;
            const maxSizesArray = maxSizesStr.split(',')
                                        .map(s => s.trim())
                                        .filter(s => s !== "")
                                        .map(s => parseInt(s));
            const seed = document.getElementById('seedInput').value;
            if (maxSizesArray.length !== k) {
                alert(`La lista de tamaños (${maxSizesArray.length}) debe coincidir con K (${k})`);
                return;
            }
            if (!confirm(`¿Reiniciar con K=${k} y Tamaño Máx=${maxSizesArray}?`)) return;
            try {
                // 1. Llamar al backend para limpiar modelos
                const res = await fetch('http://localhost:5001/reset', { 
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ k: parseInt(k), max_size: maxSizesArray, seed: parseInt(seed) })
                 });
                const data = await res.json();

                if (data.status === "success") {
                    // 2. Reiniciar estado local del Frontend
                    procesoCompletado = false;
                    stopProcess = false;
                    estaProcesando = false;
                    detectedLabels.clear();
                    
                    // 3. Limpiar Interfaz
                    document.getElementById('output').textContent = "Estado reiniciado. Esperando carpeta...";
                    detectedLabels.clear();
                    document.getElementById('output').textContent = "Backend actualizado. Listo.";
                    document.getElementById('externalTable').style.display = "none";
                    document.getElementById('internalTable').style.display = "none";
                    document.getElementById('trueLabels').innerHTML = "Clases detectadas: —";
                    document.getElementById('folderInput').value = ""; // Limpiar selección de archivos
                    document.getElementById('btnRun').disabled = false;

                    alert(data.message);
                }
            } catch (err) {
                alert("Error al reiniciar el backend: " + err.message);
            }
            
        }

        function updateUI(filename, results) {
            const output = document.getElementById('output');
            let text = `> ${filename.substring(0, 20)}... | `;
            
            // Iteramos sobre los modos (hu, sift, etc.) ignorando el campo 'filename'
            const modes = ["hu", "sift", "hog", "cnn"];
            modes.forEach(mode => {
                if (results[mode]) {
                    const res = results[mode];
                    const label = res.cluster === -1 ? "WAIT" : (res.cluster === -2 ? "FULL" : res.cluster);
                    text += `[${mode.toUpperCase()}:${label}] `;
                }
            });
            
            // Mantener el scroll al final
            output.textContent += text + "\n";
            output.scrollTop = output.scrollHeight;
        }
    </script>
</body>
</html>